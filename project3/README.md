# Networked Spell Checker (high-level overview of program) 


<br/>Hello potential client, welcome to this networked spell checker application. Networked spell checker will run with a given dictionary file (for which the word will searched from) and/or a port number. Otherwise, defaults will be used, but the default dictionary does not contain every possible word. To connect to the “server” (no fancy interface), via socket programming, the port numbers must match. 
<br/><br/>Once connected, you will be able to send a word, and the server will respond if your word is spelled correct. (word + “OK” for correct or word + “MISSPELLED” for incorrect). Doesn’t sound very interesting, but what makes the program unique, is the fact it can support multiple clients to connect and concurrently send words to be checked, with correct response going to the right client. The server will accept a word and respond to the client, until the client leaves. 
<br/><br/>For example, two USERs connect to the networked spell checker, USER1 sends “zebra”, and USER2 sends over “aapple”. USER1 will see “zebra OK”, and USER2 “apple MISSPELLED”, no interference, or a user receiving the wrong result back. Now imagine 100 different users, all sending words asynchronously, and at random intervals, the result is a single program acting as if there were 100 independent programs running for the USERs. 
<br/><br/>A “program” is designed to do something, this program receives a word and responds if that word is spelled correctly. To allow multiple clients, we can’t have that single program tend to each client one at a time, from start to finish. Instead we make use of “threads”, with each thread type having a specific function (like a subprogram of that program), and that thread can be copied, so you can have a collection of threads of the same type (same function). This single program will have a ton of moving parts, who seemingly act/ work independently of another. 
<br/><br/>The idea of having so many moving parts, can lead to more issues, such as possible overlaps 
when accessing shared data, like the dictionary resource (where the word is checked against), or
removing the wrong user’s word + OK/MISSPELLED from a queue of 50 other words. To prevent these possible errors broadly, this program make uses of locks (only a single thread can hold a lock at a time to access some data) to provide this idea of mutual exclusion, and condition variables (separate queue/s, thread can “wait” on, on some condition is true) to “synchronize” the adding and removing of words on a queue structure.  
<br/><br/>The data/results from all clients who connect and send words, is saved into a single file (data.log). On server side, I can see, thread A connected to socket B, the response to be written, and when that thread A closes connection with socket B. 
